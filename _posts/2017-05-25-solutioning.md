---
layout: post
title: solutioning
# Updated date that overrides created file date
date: 2018-03-20
---

The point is to show progress, strategies, and optimization just like real life, not "knowing the answer" which isn't possible for new problems. Drive the process like you're the senior person, but be a great teammate too!

1. Understand the problem
   * Think aloud
   * Ask questions
     * Scope the problem
     * Get clues
     * Express what you're considering or not
   * Listen for clues carefully
   * Read carefully
   * Write down notes for givens like inputs and outputs
2. Manually test out a simple, but realistic example
   * Reasonably big/realistic breadth
   * Include special cases so you don't miss edge cases
   * Reverse engineer and breakdown thoughts
3. State brute-force algorithm MVP; maybe pseudocode
   * Talk about tradeoffs like time and space complexity
4. Optimize
   * Bottlenecks
   * Unnecessary complexity
   * Duplicated work
   * Edge cases
   * Consider time and space complexity tradeoffs
     * Data structures
       * Hash tables
     * Recursion
       * Bottom-up, vs. top-down
       * Memoization
       * Dynamic programming
5. Walk through in detail; check against problem
6. Write beautiful code
   * Modularize with top-down functions first
     * May save you from writing smaller helper utility functions that aren't that important to logic
   * Refactor
   * Add arrows to insert new code instead of rewriting to save time
7. Test your code (not the algorithm)
   * Code review
     * Logic
     * Areas vulnerable to errors
   * Small test cases
   * Special edge cases
   * Big test cases (like realistic example you made above)
   * Bugs
     * Think about root causes
     * Fix them
   
Good luck and bring your own thin whiteboard markers if you like!
